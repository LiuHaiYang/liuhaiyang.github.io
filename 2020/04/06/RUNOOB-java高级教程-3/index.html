<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="meet you">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>RUNOOB-java高级教程-3 | meet you</title>


    <link rel="alternate" href="/atom.xml" title="meet you" type="application/atom+xml">


    <link rel="icon" href="/img/favicon.ico">

    


    <link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css">


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    


    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Ocean'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> Always believe youself. </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">meet you</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/python/"><i class="fa "></i>python</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/java/"><i class="fa "></i>JAVA</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/生活/"><i class="fa "></i>生活</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="RUNOOB-java高级教程-3">
            
	            RUNOOB-java高级教程-3
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/ ">
             
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/java" title='java'>
                        java
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2020/04/06</span>
        </span>
    
</div>

            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>806</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p><img src="https://images.pexels.com/photos/3944170/pexels-photo-3944170.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500" alt="image"></p>
<hr>
<ol start="3">
<li>java 序列化</li>
</ol>
<p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。</p>
<p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。</p>
<p>整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
<p>类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。</p>
<p>ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外：</p>
<p><code>public final void writeObject(Object x) throws IOException</code></p>
<p>上面的方法序列化一个对象，并将它发送到输出流。相似的 ObjectInputStream 类包含如下反序列化一个对象的方法：</p>
<p><code>public final Object readObject() throws IOException, 
                                 ClassNotFoundException</code></p>
<p>该方法从流中取出下一个对象，并将对象反序列化。它的返回值为Object，因此，你需要将它转换成合适的数据类型。</p>
<p>为了演示序列化在Java中是怎样工作的，我将使用之前教程中提到的Employee类，假设我们定义了如下的Employee类，该类实现了Serializable 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Employee implements java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">   public String name;</span><br><span class="line">   public String address;</span><br><span class="line">   public transient int SSN;</span><br><span class="line">   public int number;</span><br><span class="line">   public void mailCheck()</span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(&quot;Mailing a check to &quot; + name</span><br><span class="line">                           + &quot; &quot; + address);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，一个类的对象要想序列化成功，必须满足两个条件：</p>
<p>该类必须实现 java.io.Serializable 接口。</p>
<p>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</p>
<p>如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。</p>
<h3 id="反序列化对象"><a href="#反序列化对象" class="headerlink" title="反序列化对象"></a>反序列化对象</h3><p>下面的 DeserializeDemo 程序实例了反序列化，/tmp/employee.ser 存储了 Employee 对象。</p>
<p>DeserializeDemo.java 文件代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line"> </span><br><span class="line">public class DeserializeDemo</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String [] args)</span><br><span class="line">   &#123;</span><br><span class="line">      Employee e = null;</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">         FileInputStream fileIn = new FileInputStream(&quot;/tmp/employee.ser&quot;);</span><br><span class="line">         ObjectInputStream in = new ObjectInputStream(fileIn);</span><br><span class="line">         e = (Employee) in.readObject();</span><br><span class="line">         in.close();</span><br><span class="line">         fileIn.close();</span><br><span class="line">      &#125;catch(IOException i)</span><br><span class="line">      &#123;</span><br><span class="line">         i.printStackTrace();</span><br><span class="line">         return;</span><br><span class="line">      &#125;catch(ClassNotFoundException c)</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(&quot;Employee class not found&quot;);</span><br><span class="line">         c.printStackTrace();</span><br><span class="line">         return;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Deserialized Employee...&quot;);</span><br><span class="line">      System.out.println(&quot;Name: &quot; + e.name);</span><br><span class="line">      System.out.println(&quot;Address: &quot; + e.address);</span><br><span class="line">      System.out.println(&quot;SSN: &quot; + e.SSN);</span><br><span class="line">      System.out.println(&quot;Number: &quot; + e.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意以下要点：</p>
<p>readObject() 方法中的 try/catch代码块尝试捕获 ClassNotFoundException 异常。对于 JVM 可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个 ClassNotFoundException 异常。</p>
<p>注意，readObject() 方法的返回值被转化成 Employee 引用。</p>
<p>当对象被序列化时，属性 SSN 的值为 111222333，但是因为该属性是短暂的，该值没有被发送到输出流。所以反序列化后 Employee 对象的 SSN 属性为 0。</p>
<ol start="4">
<li>java 网络编程</li>
</ol>
<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。</p>
<p>java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>
<p>java.net 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li>TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。</li>
<li>UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。</li>
</ul>
<p>主要讲解以下两个主题。</p>
<ul>
<li>Socket 编程：这是使用最广泛的网络概念，它已被解释地非常详细。</li>
<li>URL 处理：这部分会在另外的篇幅里讲</li>
</ul>
<h3 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h3><p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p>
<p>当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。</p>
<p>java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p>
<p>以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：</p>
<ul>
<li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li>
<li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
<li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li>
<li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
<li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li>
</ul>
<p>连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p>
<p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。</p>
<h3 id="ServerSocket-类的方法"><a href="#ServerSocket-类的方法" class="headerlink" title="ServerSocket 类的方法"></a>ServerSocket 类的方法</h3><p>服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。</p>
<p>ServerSocket 类有四个构造方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>public ServerSocket(int port) throws IOException</td>
<td>创建绑定到特定端口的服务器套接字。</td>
</tr>
<tr>
<td>2</td>
<td>public ServerSocket(int port, int backlog) throws IOException</td>
<td>利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。</td>
</tr>
<tr>
<td>3</td>
<td>public ServerSocket(int port, int backlog, InetAddress address) throws IOException</td>
<td>使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。</td>
</tr>
<tr>
<td>4</td>
<td>public ServerSocket() throws IOException</td>
<td>创建非绑定服务器套接字。</td>
</tr>
</tbody>
</table>
<p>创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。</p>
<p>这里有一些 ServerSocket 类的常用方法：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>public int getLocalPort()</td>
<td>返回此套接字在其上侦听的端口。</td>
</tr>
<tr>
<td>2</td>
<td>public Socket accept() throws IOException</td>
<td>侦听并接受到此套接字的连接。</td>
</tr>
<tr>
<td>3</td>
<td>public void setSoTimeout(int timeout)</td>
<td>通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。</td>
</tr>
<tr>
<td>4</td>
<td>public void bind(SocketAddress host, int backlog)</td>
<td>将 ServerSocket 绑定到特定地址（IP 地址和端口号）。</td>
</tr>
</tbody>
</table>
<h3 id="Socket-类的方法"><a href="#Socket-类的方法" class="headerlink" title="Socket 类的方法"></a>Socket 类的方法</h3><p>java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。</p>
<p>Socket 类有五个构造方法.</p>
<ul>
<li>public Socket(String host, int port) throws UnknownHostException, IOException.创建一个流套接字并将其连接到指定主机上的指定端口号。</li>
<li>public Socket(InetAddress host, int port) throws IOException创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li>
<li>public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程主机上的指定远程端口。</li>
<li>public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程地址上的指定远程端口。</li>
<li>public Socket() 通过系统默认类型的 SocketImpl 创建未连接套接字</li>
</ul>
<p>当 Socket 构造方法返回，并没有简单的实例化了一个 Socket 对象，它实际上会尝试连接到指定的服务器和端口。</p>
<p>下面列出了一些感兴趣的方法，注意客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。</p>
<ul>
<li>public void connect(SocketAddress host, int timeout) throws IOException 将此套接字连接到服务器，并指定一个超时值。</li>
<li>public InetAddress getInetAddress() 返回套接字连接的地址。</li>
<li>public int getPort() 返回此套接字连接到的远程端口。</li>
<li>public int getLocalPort() 返回此套接字绑定到的本地端口。</li>
<li>public SocketAddress getRemoteSocketAddress() 返回此套接字连接的端点的地址，如果未连接则返回 null。</li>
<li>public InputStream getInputStream() throws IOException 返回此套接字的输入流。</li>
<li>public OutputStream getOutputStream() throws IOException 返回此套接字的输出流。</li>
<li>public void close() throws IOException 关闭此套接字。</li>
</ul>
<h3 id="Socket-客户端实例"><a href="#Socket-客户端实例" class="headerlink" title="Socket 客户端实例"></a>Socket 客户端实例</h3><p>如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。</p>
<p>GreetingClient.java 文件代码：<br>// 文件名 GreetingClient.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"> </span><br><span class="line">public class GreetingClient</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String [] args)</span><br><span class="line">   &#123;</span><br><span class="line">      String serverName = args[0];</span><br><span class="line">      int port = Integer.parseInt(args[1]);</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(&quot;连接到主机：&quot; + serverName + &quot; ，端口号：&quot; + port);</span><br><span class="line">         Socket client = new Socket(serverName, port);</span><br><span class="line">         System.out.println(&quot;远程主机地址：&quot; + client.getRemoteSocketAddress());</span><br><span class="line">         OutputStream outToServer = client.getOutputStream();</span><br><span class="line">         DataOutputStream out = new DataOutputStream(outToServer);</span><br><span class="line"> </span><br><span class="line">         out.writeUTF(&quot;Hello from &quot; + client.getLocalSocketAddress());</span><br><span class="line">         InputStream inFromServer = client.getInputStream();</span><br><span class="line">         DataInputStream in = new DataInputStream(inFromServer);</span><br><span class="line">         System.out.println(&quot;服务器响应： &quot; + in.readUTF());</span><br><span class="line">         client.close();</span><br><span class="line">      &#125;catch(IOException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Socket-服务端实例"><a href="#Socket-服务端实例" class="headerlink" title="Socket 服务端实例"></a>Socket 服务端实例</h3><p>如下的GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。</p>
<p>GreetingServer.java 文件代码：<br>// 文件名 GreetingServer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import java.net.*;</span><br><span class="line">import java.io.*;</span><br><span class="line"> </span><br><span class="line">public class GreetingServer extends Thread</span><br><span class="line">&#123;</span><br><span class="line">   private ServerSocket serverSocket;</span><br><span class="line">   </span><br><span class="line">   public GreetingServer(int port) throws IOException</span><br><span class="line">   &#123;</span><br><span class="line">      serverSocket = new ServerSocket(port);</span><br><span class="line">      serverSocket.setSoTimeout(10000);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void run()</span><br><span class="line">   &#123;</span><br><span class="line">      while(true)</span><br><span class="line">      &#123;</span><br><span class="line">         try</span><br><span class="line">         &#123;</span><br><span class="line">            System.out.println(&quot;等待远程连接，端口号为：&quot; + serverSocket.getLocalPort() + &quot;...&quot;);</span><br><span class="line">            Socket server = serverSocket.accept();</span><br><span class="line">            System.out.println(&quot;远程主机地址：&quot; + server.getRemoteSocketAddress());</span><br><span class="line">            DataInputStream in = new DataInputStream(server.getInputStream());</span><br><span class="line">            System.out.println(in.readUTF());</span><br><span class="line">            DataOutputStream out = new DataOutputStream(server.getOutputStream());</span><br><span class="line">            out.writeUTF(&quot;谢谢连接我：&quot; + server.getLocalSocketAddress() + &quot;\nGoodbye!&quot;);</span><br><span class="line">            server.close();</span><br><span class="line">         &#125;catch(SocketTimeoutException s)</span><br><span class="line">         &#123;</span><br><span class="line">            System.out.println(&quot;Socket timed out!&quot;);</span><br><span class="line">            break;</span><br><span class="line">         &#125;catch(IOException e)</span><br><span class="line">         &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            break;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String [] args)</span><br><span class="line">   &#123;</span><br><span class="line">      int port = Integer.parseInt(args[0]);</span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">         Thread t = new GreetingServer(port);</span><br><span class="line">         t.run();</span><br><span class="line">      &#125;catch(IOException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="程序交互状态"><a href="#程序交互状态" class="headerlink" title="程序交互状态"></a>程序交互状态</h3><h4 id="同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO-操作并等待或者轮询的去查看IO-操作是否就绪，而异步是指用户进程触发IO-操作以后便开始做自己的事情，而当IO-操作已经完成的时候会得到IO-完成的通知。"><a href="#同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO-操作并等待或者轮询的去查看IO-操作是否就绪，而异步是指用户进程触发IO-操作以后便开始做自己的事情，而当IO-操作已经完成的时候会得到IO-完成的通知。" class="headerlink" title="同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。"></a>同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。</h4><p>以银行取款为例：</p>
<ul>
<li>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理IO 读写）；</li>
<li>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO 时，Java 将 IO 读写委托给OS 处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS 需要支持异步IO操作API）；</li>
</ul>
<h4 id="阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。"><a href="#阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。" class="headerlink" title="阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。"></a>阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。</h4><p>以银行取款为例：</p>
<ul>
<li>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；</li>
<li>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器通知可读写时再继续进行读写，不断循环直到读写完成）</li>
</ul>
<h4 id="BIO-编程"><a href="#BIO-编程" class="headerlink" title="BIO 编程"></a>BIO 编程</h4><p>Blocking IO： 同步阻塞的编程方式。</p>
<ul>
<li>BIO编程方式通常是在JDK1.4版本之前常用的编程方式。编程实现过程为：首先在服务端启动一个ServerSocket来监听网络请求，客户端启动Socket发起网络请求，默认情况下ServerSocket回建立一个线程来处理此请求，如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。</li>
<li>且建立好的连接，在通讯过程中，是同步的。在并发处理效率上比较低。大致结构如下：</li>
<li>同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</li>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
</ul>
<p>使用线程池机制改善后的BIO模型图如下:</p>
<h4 id="NIO-编程：Unblocking-IO（New-IO）：-同步非阻塞的编程方式。"><a href="#NIO-编程：Unblocking-IO（New-IO）：-同步非阻塞的编程方式。" class="headerlink" title="NIO 编程：Unblocking IO（New IO）： 同步非阻塞的编程方式。"></a>NIO 编程：Unblocking IO（New IO）： 同步非阻塞的编程方式。</h4><p>NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题，NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。</p>
<p>NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。</p>
<p>在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题</p>
<h4 id="AIO编程：Asynchronous-IO：-异步非阻塞的编程方式。"><a href="#AIO编程：Asynchronous-IO：-异步非阻塞的编程方式。" class="headerlink" title="AIO编程：Asynchronous IO： 异步非阻塞的编程方式。"></a>AIO编程：Asynchronous IO： 异步非阻塞的编程方式。</h4><p>与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：AsynchronousSocketChannel、AsynchronousServerSocketChannel、AsynchronousFileChannel、AsynchronousDatagramChannel</p>
<p>bio示例</p>
<p>server示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int port = genPort(args);</span><br><span class="line">        </span><br><span class="line">        ServerSocket server = null;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(50);</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            server = new ServerSocket(port);</span><br><span class="line">            System.out.println(&quot;server started!&quot;);</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                </span><br><span class="line">                service.execute(new Handler(socket));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            if(server != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    server.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            server = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class Handler implements Runnable&#123;</span><br><span class="line">        Socket socket = null;</span><br><span class="line">        public Handler(Socket socket)&#123;</span><br><span class="line">            this.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            BufferedReader reader = null;</span><br><span class="line">            PrintWriter writer = null;</span><br><span class="line">            try&#123;</span><br><span class="line">                </span><br><span class="line">                reader = new BufferedReader(</span><br><span class="line">                        new InputStreamReader(socket.getInputStream(), &quot;UTF-8&quot;));</span><br><span class="line">                writer = new PrintWriter(</span><br><span class="line">                        new OutputStreamWriter(socket.getOutputStream(), &quot;UTF-8&quot;));</span><br><span class="line">                String readMessage = null;</span><br><span class="line">                while(true)&#123;</span><br><span class="line">                    System.out.println(&quot;server reading... &quot;);</span><br><span class="line">                    if((readMessage = reader.readLine()) == null)&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(readMessage);</span><br><span class="line">                    writer.println(&quot;server recive : &quot; + readMessage);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;finally&#123;</span><br><span class="line">                if(socket != null)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                socket = null;</span><br><span class="line">                if(reader != null)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        reader.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                reader = null;</span><br><span class="line">                if(writer != null)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">                writer = null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int genPort(String[] args)&#123;</span><br><span class="line">        if(args.length &gt; 0)&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                return Integer.parseInt(args[0]);</span><br><span class="line">            &#125;catch(NumberFormatException e)&#123;</span><br><span class="line">                return 9999;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 9999;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.client示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String host = null;</span><br><span class="line">        int port = 0;</span><br><span class="line">        if(args.length &gt; 2)&#123;</span><br><span class="line">            host = args[0];</span><br><span class="line">            port = Integer.parseInt(args[1]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            host = &quot;127.0.0.1&quot;;</span><br><span class="line">            port = 9999;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Socket socket = null;</span><br><span class="line">        BufferedReader reader = null;</span><br><span class="line">        PrintWriter writer = null;</span><br><span class="line">        Scanner s = new Scanner(System.in);</span><br><span class="line">        try&#123;</span><br><span class="line">            socket = new Socket(host, port);</span><br><span class="line">            String message = null;</span><br><span class="line">            </span><br><span class="line">            reader = new BufferedReader(</span><br><span class="line">                    new InputStreamReader(socket.getInputStream(), &quot;UTF-8&quot;));</span><br><span class="line">            writer = new PrintWriter(</span><br><span class="line">                    socket.getOutputStream(), true);</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                message = s.nextLine();</span><br><span class="line">                if(message.equals(&quot;exit&quot;))&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                writer.println(message);</span><br><span class="line">                writer.flush();</span><br><span class="line">                System.out.println(reader.readLine());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            if(socket != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            socket = null;</span><br><span class="line">            if(reader != null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            reader = null;</span><br><span class="line">            if(writer != null)&#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">            writer = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DatagramSocket-UDP-简单示例"><a href="#DatagramSocket-UDP-简单示例" class="headerlink" title="DatagramSocket(UDP)简单示例"></a>DatagramSocket(UDP)简单示例</h3><p>服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DatagramSocket server = new DatagramSocket(5060);</span><br><span class="line">            DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);</span><br><span class="line">            server.receive(packet);</span><br><span class="line">            System.out.println(packet.getAddress().getHostName() + &quot;(&quot; + packet.getPort() + &quot;):&quot; + new String(packet.getData()));</span><br><span class="line">            packet.setData(&quot;Hello Client&quot;.getBytes());</span><br><span class="line">            packet.setPort(5070);</span><br><span class="line">            packet.setAddress(InetAddress.getLocalHost());</span><br><span class="line">            server.send(packet);</span><br><span class="line">            server.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DatagramSocket client = new DatagramSocket(5070);</span><br><span class="line">            DatagramPacket packet = new DatagramPacket(new byte[1024],1024);</span><br><span class="line">            packet.setPort(5060);</span><br><span class="line">            packet.setAddress(InetAddress.getLocalHost());</span><br><span class="line">            packet.setData(&quot;Hello Server&quot;.getBytes());</span><br><span class="line">            client.send(packet);</span><br><span class="line">            client.receive(packet);</span><br><span class="line">            System.out.println(packet.getAddress().getHostName() + &quot;(&quot; + packet.getPort() + &quot;):&quot; + new String(packet.getData()));</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 ,图片资源转自pexels © <a href="" target="_blank">Ocean</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2020/04/26/HTTP协议头部和keep-alive模式详解/" class="pre-post btn btn-default" title='HTTP协议头部和keep-alive模式详解'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">HTTP协议头部和keep-alive模式详解</span>
        </a>
    
    
        <a href="/2020/04/05/RUNOOB-java高级教程-2/" class="next-post btn btn-default" title='RUNOOB-java高级教程-2'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">RUNOOB-java高级教程-2</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	<link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script>

<script>
    var gitment = new Gitment({
        id: 'Mon Apr 06 2020 21:13:37 GMT+0800',
        owner:"LiuHaiYang",
        repo:"liuhaiyang.github.io",
        oauth: {
          client_id:"aacf4f5555aee5bf0770",
          client_secret:"07f91d5b66c30419c14d14349ccadaa91300bc9c"
        },
        perPage:"10",
    });
    gitment.render('comments');
</script>

    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#反序列化对象"><span class="toc-text">反序列化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-编程"><span class="toc-text">Socket 编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerSocket-类的方法"><span class="toc-text">ServerSocket 类的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-类的方法"><span class="toc-text">Socket 类的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-客户端实例"><span class="toc-text">Socket 客户端实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-服务端实例"><span class="toc-text">Socket 服务端实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序交互状态"><span class="toc-text">程序交互状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO-操作并等待或者轮询的去查看IO-操作是否就绪，而异步是指用户进程触发IO-操作以后便开始做自己的事情，而当IO-操作已经完成的时候会得到IO-完成的通知。"><span class="toc-text">同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。"><span class="toc-text">阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO-编程"><span class="toc-text">BIO 编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO-编程：Unblocking-IO（New-IO）：-同步非阻塞的编程方式。"><span class="toc-text">NIO 编程：Unblocking IO（New IO）： 同步非阻塞的编程方式。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AIO编程：Asynchronous-IO：-异步非阻塞的编程方式。"><span class="toc-text">AIO编程：Asynchronous IO： 异步非阻塞的编程方式。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DatagramSocket-UDP-简单示例"><span class="toc-text">DatagramSocket(UDP)简单示例</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2019
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Ocean</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>
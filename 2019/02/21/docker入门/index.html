<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="meet you">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>docker入门 | meet you</title>


    <link rel="alternate" href="/atom.xml" title="meet you" type="application/atom+xml">


    <link rel="icon" href="/img/favicon.ico">

    


    <link rel="stylesheet" href="//imsun.github.io/gitment/style/default.css">


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    


    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Ocean'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> Always believe youself. </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">meet you</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/python/"><i class="fa "></i>python</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/java/"><i class="fa "></i>JAVA</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/生活/"><i class="fa "></i>生活</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="docker入门">
            
	            docker入门
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/ ">
             
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/linux" title='linux'>
                        linux
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/02/21</span>
        </span>
    
</div>

            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>904</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p><img src="https://images.pexels.com/photos/1803027/pexels-photo-1803027.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=1&amp;w=500" alt="image"></p>
<h2 id="docker-学习操作记录"><a href="#docker-学习操作记录" class="headerlink" title="docker 学习操作记录"></a>docker 学习操作记录</h2><h4 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h4><ul>
<li><p>启动容器：</p>
<p> $ docker run IMAGE [CIMMAND] [ARG…]</p>
</li>
<li><p>启动容器 并输出 helloworld</p>
<p> $ docker run ubuntu echo ‘hello world’</p>
</li>
</ul>
<h4 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h4><pre><code>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。
</code></pre><ul>
<li><p>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。</p>
<pre><code>请在该配置文件中加入（没有该文件的话，请先建一个）：

{
  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]
}
或者：https://blog.csdn.net/shenzhen_zsw/article/details/74277518
进入官网 docker加速器
http://guide.daocloud.io/dcs/docker-9153151.html
</code></pre></li>
</ul>
<h4 id="基础命令："><a href="#基础命令：" class="headerlink" title="基础命令："></a>基础命令：</h4><ul>
<li><p>使用bash 启动：</p>
<p> <code>$ docker run -i -t ubuntu /bin/bash</code></p>
</li>
<li><p>查看 容器：</p>
<p> <code>$ docker ps [-a]  [-l</code> 不加参数时，返回的是正在运行的容器！</p>
<pre><code>-a 查看所有的容器
-l 查看最new创建的容器
</code></pre></li>
<li><p>$ <code>docker inspect [容器的id]</code> 会对容器进行详细的检查！</p>
</li>
<li><p>自定义容器名：<code>$ docker run --name= 自定义名 -i -t IMAGE /bin/bash</code></p>
</li>
<li><p>重新启动已停止的容器：</p>
<p> <code>$ docker start [-i] 容器名</code><br> -i 已交互的方式重启</p>
</li>
<li><p><code>$ docker rm 容器名/id</code>  删除已经停止的容器</p>
</li>
<li><p>docker 守护式容器</p>
<pre><code>启动后可以 Ctrl+p  / Ctrl+Q 进行退出
退出了交互式 容器 后台还在运行
</code></pre><p>-<code>$ docker attach 容器名/id</code>  可以进入后台运行的容器</p>
</li>
<li><p>run 命令启动守护式容器：</p>
<pre><code>`$ docker run -d IMAGE `
-d 后台启动
`docker run --dc1 -d ubuntu /bin/bash -c &quot;while true; do echo helloworld; sleep 1; done&quot;`
</code></pre></li>
</ul>
<ul>
<li><p><code>$ docker logs</code> 返回日志 不指定 返回所有的日志</p>
<pre><code>-f 一直跟踪log 变化并返回
-t 返回结果加输出时间
--tail 结尾处数量的指定
</code></pre><ul>
<li><p><code>docker top</code> 查看容器内的进程</p>
<pre><code>在运行的容器中启动新的进程：docker exec 
 -d  -i  -t
</code></pre></li>
<li><p><code>docker exec -i -t dc1 /bin/bash</code></p>
</li>
<li><p>停止运行中的容器：</p>
<pre><code>docker stop 容器/id
docker kill 容器名/id
</code></pre></li>
</ul>
</li>
</ul>
<h4 id="容器中部署web-网站"><a href="#容器中部署web-网站" class="headerlink" title="容器中部署web 网站"></a>容器中部署web 网站</h4><ol>
<li><p>设置的容器的端口映射 </p>
<p><code>containerPort  只指定容器的端口</code></p>
<p><code>run -P -p</code></p>
<p><code>docker run -p 80 -i -t ubuntu /bin/bash</code></p>
</li>
<li><p>宿主机和容器的端口通知指定</p>
<p><code>hostPort：containerport</code></p>
<p><code>docker run -p 8080:80 -i -t ubuntu /bin/bash</code></p>
<p>3.<code>ip::containerPort</code></p>
<p><code>ocker run -p 0.0.0.0:80 -i -t ubuntu /bin/bash</code></p>
</li>
<li><p><code>ip:hostPort:containerPort</code></p>
<pre><code>docker run -p 0.0.0.0:8080:80 -i -t ubuntu /bin/bash 
docker run -p 80 --name web -i -t ubuntu /bin/bash
apt-get install nginx
apt-get install vim
</code></pre></li>
</ol>
<ul>
<li><p>操作：</p>
<pre><code>mkdir -p /var/www/html

cd /var/www/html
vim index.html

&lt;html&gt;
&lt;head&gt;nginx in docker&lt;/head&gt;
&lt;body&gt;
hello, i&apos;m website in docler
&lt;/body&gt;
&lt;/html&gt; 
</code></pre><p> <code>whereis nginx</code></p>
<p> 配置nginx 修改root文件目录<br> 到根目录 启动 nginx<br> ps -ef 查看容器中的进程<br> Ctrl +q/Q  可后台运行退出！</p>
<pre><code>docker ps 可查看刚才容器 可以看到其端口映射
docker port web 可查看端口映射
docker top web 查看容器中进程运行的情况

docker inspect web  查看该容器的ip地址
</code></pre></li>
</ul>
<h4 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h4><pre><code>镜像：使用联合加载技术实现的层叠的只读文件系统。是容器构建的基石。
存储位置： /var/lib/docker
docker info 来查看docker的基本信息
</code></pre><h4 id="镜像的操作："><a href="#镜像的操作：" class="headerlink" title="镜像的操作："></a>镜像的操作：</h4><p> 查看：</p>
<pre><code>docekr images [OPTIONS] [repository]
-a ,--all=false
-f ,--filter=[]
--no-trunc=false
-q ,--quiet=false
</code></pre><p>eg:<br>    <code>docker image</code> 列出当前已经在docker已经安装的镜像。</p>
<ul>
<li>REPOSITORY 仓库  镜像的集合。一个仓库包含的是一系列关联的镜像</li>
<li>REGISTRY 仓库 包含了很多 REPOSITORY </li>
<li><p>不同的镜像是以标签的形式来区分的。REPOSITORY+TAG 就构成了一个完整的镜像名字。对应一个镜像的ID</p>
<p>  <code>eg： ubuntu：14.04  ubuntu：laste</code></p>
<pre><code>docker images --no-trunc 查看完整的image id
docker images -a 显示所有的镜像 很多没有仓库名 tag 即中间层镜像 docker images  -q 只返回 id 一列
</code></pre><ul>
<li><p>docker images 仓库名  返回该名的所有镜像信息</p>
</li>
<li><p>查看镜像的详细信息：</p>
<pre><code>docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]
支持镜像的查看，容器的查看。
</code></pre></li>
</ul>
</li>
<li><p>删除镜像</p>
<pre><code>docker rmi [OPTIONS] IMAGE [IMAGE]
-f ,--force=flase  强制删除
--no-prune=flase   保留被打标签的父镜像
</code></pre><p>eg:</p>
<pre><code>  docker rmi ubuntu:14.04 可以跟多个镜像名和tag  or id
  docker rmi id （简短形式or完整形式 都可以）

当 镜像有多个相同的 镜像标签，删除时只是单纯的删除一个标签，实际上是没有删除镜像。
删除所有标签后 会删除此镜像。
当用 id 删除时，也会删除所有的标签，删除此镜像。
</code></pre></li>
<li><p>删除所有的镜像：</p>
<pre><code>eg：docker rmi $(docker images -q  ubuntu)  删除仓库中所有的ubuntu镜像
</code></pre></li>
</ul>
<h4 id="获取和推送镜像"><a href="#获取和推送镜像" class="headerlink" title="获取和推送镜像"></a>获取和推送镜像</h4><ul>
<li><p>查找镜像:</p>
<pre><code>1. docker Hub  https://registry.hub.docker.com
2. docekr search [OPTIONS] team
    --automated=false 显示自动化构建出的 镜像
    --no-trunc=flase  不以截断的形式显示
    -s 星级的筛选
</code></pre></li>
</ul>
<p><code>eg: docker search ubuntu</code></p>
<ul>
<li><p>拉取镜像：</p>
<pre><code>doker pull [OPTIONS] NAME [:TAG]

-a, --all=flase 
eg： docker pull ubuntu：14.04
</code></pre></li>
</ul>
<h4 id="镜像配置："><a href="#镜像配置：" class="headerlink" title="镜像配置："></a>镜像配置：</h4><pre><code>正常会特别的慢。可以使用 -registry-mirror 选项 可以使用国内的docker镜像服务器
1.修改 /etc/default/docker
2.添加： DOCKER_OPTS = &quot;registry-mirror=https:mittor_addr&quot;
https://www.daocloud.io
</code></pre><h4 id="推送镜像："><a href="#推送镜像：" class="headerlink" title="推送镜像："></a>推送镜像：</h4><pre><code>docker push 镜像名
不会提交整个镜像，只会提交修改的部分。
</code></pre><h4 id="如何让构建docker的镜像："><a href="#如何让构建docker的镜像：" class="headerlink" title="如何让构建docker的镜像："></a>如何让构建docker的镜像：</h4><pre><code>保存对容器的修改，并再次使用。
自定义镜像的能力
以软件的形式打包并分发服务及其运行环境

docker commit 通过容器构建镜像
docker commit [OPTIONS] container [PEROSITORY[:tag]]
-a ， --author 镜像的作者
-m ，--message=&quot;&quot; 构建的信息
-P --pause=true  不暂停该容器进行构建镜像
</code></pre><h4 id="实践："><a href="#实践：" class="headerlink" title="实践："></a>实践：</h4><pre><code>docker run -it -p 80 --name commit_test ubuntu /bin/bash
apt-get update
apt-get install nginx
exit
</code></pre><h4 id="提交为镜像："><a href="#提交为镜像：" class="headerlink" title="提交为镜像："></a>提交为镜像：</h4><pre><code>docker commit -a &apos;harry&apos; -m &quot;nginx&quot; commit_test （容器名）  dormancypress/commit_test1 (为镜像起一个名字)

返回一个唯一id，就是新生成的镜像的id
docker ps
</code></pre><h4 id="docker-build-通过Dockerfile-文件构建"><a href="#docker-build-通过Dockerfile-文件构建" class="headerlink" title="docker build 通过Dockerfile 文件构建"></a>docker build 通过Dockerfile 文件构建</h4><p>1.创建Dockerfile 文件   包含一系列命令的文本文件<br>    eg：</p>
<pre><code>#First Dockerfile
FROM ubuntu：14.04
MAINUAINER dormancypress &quot;xxxx@qq.com&quot;
RUN apt-get update
RUN apt-get install -y nginx
EXPORT 80
</code></pre><p><code>mkdir -p dockerfile/df_test</code></p>
<p>进入后把刚才的内容填写到文件,执行<code>docker build</code></p>
<p>2.使用$docker build 命令</p>
<pre><code>docker build -t &quot;镜像名字&quot;   dockerfile 的地址
</code></pre><h3 id="Docker的cs模式："><a href="#Docker的cs模式：" class="headerlink" title="Docker的cs模式："></a>Docker的cs模式：</h3><p>客户端c：</p>
<ol>
<li>docker 命令行客户端</li>
<li>Remote API  RESTFul 风格API  自己的程序可以与docker 集成 </li>
</ol>
<p>cs的链接方式： socket 3种：</p>
<pre><code>1. unix:///var/run/docker.sock  默认的链接方式，可修改。
2. tcp://host:port
3. fd://socketfd
</code></pre><p>cs可在同一台机器或不在同一台，远程链接</p>
<ul>
<li><p>实现socket的链接：<br>  <code>nc -U （指明是socket） /var/run/docker.sock</code> (输入后就已经连接到socket)</p>
<ul>
<li>操作：<pre><code>GET /info (调用remote API info  则返回相关信息)HTTP/1.1   (协议)
</code></pre>返回数据是json格式、</li>
</ul>
</li>
</ul>
<h4 id="docker-守护进程的配置和操作"><a href="#docker-守护进程的配置和操作" class="headerlink" title="docker 守护进程的配置和操作"></a>docker 守护进程的配置和操作</h4><pre><code>查看docker的状态
sudo status docker

使用service 命令操作：
sudo service docker start
sudo service docker stop
sudo service doxker restart
</code></pre><h4 id="docker-de-启动及选项：很多"><a href="#docker-de-启动及选项：很多" class="headerlink" title="docker de 启动及选项：很多"></a>docker de 启动及选项：很多</h4><pre><code>docker -d [OPTIONS]
-D, --debug=false 
-e, --exec-driver=&quot;native&quot;
-g,--graph=&quot;var/lib/docker&quot;
--icc=true
-l,--log-level=&quot;info&quot; 日志级别 
--label=[]
-p,--pidfile=&quot;/var/lib/docker.pid&quot;  写入id的地址
</code></pre><p>及：</p>
<pre><code>docker 服务器相关的选项
存储相关 
remoteAPI相关
驱动相关
Redistry 仓库链接相关的
网络相关的 DNS 等
</code></pre><p>有灵活的设置选项<br>具体文档查看地址：<br>        <code>https://docs.docker.com/reference/commandline/cli</code></p>
<p>启动配置文件： <code>/etc/default/docker</code><br>可以设置docker的启动时的各种选项。</p>
<h3 id="docker-的远程访问"><a href="#docker-的远程访问" class="headerlink" title="docker 的远程访问"></a>docker 的远程访问</h3><p>docker的客户端与守护进程的远程访问。 不在同一台机器。<br>保证 ClientAPI 和 SercerAPI 版本一致。</p>
<h4 id="客户端修改"><a href="#客户端修改" class="headerlink" title="客户端修改"></a>客户端修改</h4><p>修改原有服务器的启动配置文件。 <code>vim /etc/default/docker</code><br>两台机器 可添加 <code>DOCKER_OPTS = &quot;label name=docker_server_1/2&quot;</code></p>
<p>重启<code>docker</code><br><code>docker info</code> 查看添加的信息，存在 则客户端信息已经修改好。</p>
<h4 id="服务器端修改"><a href="#服务器端修改" class="headerlink" title="服务器端修改"></a>服务器端修改</h4><p>-H docker 守护进程启动选项</p>
<p>守护进程默认配置：</p>
<pre><code>-H unix:///var/run/docker.sock
继续修改 DOCKER_OPTS  的值：
DOCKER_OPTS  后面添加 -H tcp://0.0.0.0:2375
</code></pre><p>重启 并查看<code>ps -ef | grep dcoker</code></p>
<p>可看到修改后的服务端配置信息,查看ip  </p>
<pre><code>到另一台机器测试连接 
curl http://x.x.x.x:2374/info
客户端查看：-H
docker -H tcp://10.211.55.5:2375  info
</code></pre><p>客户端 提供了简化操作， 配置环境变量<code>DOCKER_HOST</code><br>执行命令<code>export DOCKER_HOST=&quot;tcp://x.x.x.x:2375&quot;</code></p>
<p>直接运行 info 测试 返回的就是远程的 信息<br>若要连本地自己的，只需 <code>export DOCKER_HOST =&#39;&#39;</code> 置空 就行，为默认配置</p>
<p>-H 可以指定多个参数值</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h4 id="第一个-Dockerfile"><a href="#第一个-Dockerfile" class="headerlink" title="第一个 Dockerfile"></a>第一个 Dockerfile</h4><pre><code>FROM UBUNTU:14.04
MAINTAINER dormancypress &quot;xxxx@qq.com&quot;
RUN apt-get update
RUN apt-get install -y nginx
EXPOSE 80
</code></pre><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li>FROM  <image> or <a href="image:tag" target="_blank" rel="noopener">image:tag</a>  <ul>
<li>已存在的镜像</li>
<li>基础镜像</li>
<li>必须是第一条非注释的指令</li>
</ul>
</image></li>
<li>MAINTAINER  作者名 及 email地址</li>
<li><p>RUN  当前镜像中的命令</p>
<ul>
<li>RUN <command>  (shell 模式)</li>
<li>RUN [‘EXEC’, ‘PARAM1’] (EXEC 模式)</li>
<li>分层概念</li>
<li>会在当前镜像的上层创建新的镜像运行命令</li>
</ul>
</li>
<li><p>EXPOSE  指定运行该镜像的容器使用的端口，</p>
</li>
<li><p>CMD</p>
</li>
<li>ENTERYPOINT</li>
<li>ADD</li>
<li>COPY</li>
<li>VOLUME</li>
<li>WORKDIR</li>
<li>ENV</li>
<li>USER</li>
<li>ONBUILD</li>
</ul>
<p>端口制定后还需要在创建容器时手动的指定 端口</p>
<h3 id="Docker容器的网络基础"><a href="#Docker容器的网络基础" class="headerlink" title="Docker容器的网络基础"></a>Docker容器的网络基础</h3><p>docker0 为容器网络提供网络连接<br>linux 中的虚拟网桥<br>OSI 七层模型中的网桥<br>网桥时七层模型中 数据链路层中的设备<br>通过mac 地址对网络进行划分，在不同的之间进行通信</p>
<p>linux虚拟网桥的特点：</p>
<ul>
<li>可以设置IP地址</li>
<li>相当拥有一个隐藏的虚拟网桥</li>
</ul>
<p>docker0 的地址划分：</p>
<pre><code>- ip： 172.17.42.1 子网掩码：255.255.0.0
- MAC：02:42:ac:11:00:00  到 02:42:ac:11:ff:ff
- 总共提供了 65534 个地址
- 对每一个容器提供一个 mac ip
</code></pre><p>需要网桥管理工具，安装： <code>apt-get install bridge-utils</code><br>运行： <code>sudo brctl show</code>  查看网桥设备</p>
<p>可自定义docker0</p>
<ul>
<li>满足我们对容器网络的一些要求。</li>
<li><code>eg： sudo ifconfig docker0 192.168.200.1 network 255.255.255.0</code></li>
</ul>
<p>自定义虚拟网桥：</p>
<ul>
<li><p>添加虚拟网桥</p>
<pre><code>sudo brctl addbr br0
sudo ifconfig br0 192.168.100.1 network 255.255.255.0
</code></pre></li>
<li><p>更改 docker 守护进程的启动配置：<br>  <code>/etc/default/docker</code>中添加 <code>DOCKER_OPTS 值
  -b = br0</code></p>
</li>
</ul>
<h3 id="容器的互联"><a href="#容器的互联" class="headerlink" title="容器的互联"></a>容器的互联</h3><ul>
<li>默认：允许所有容器的互联</li>
</ul>
<p>容器重启后ip就改变了，解决办法是<br><code>--link</code></p>
<p><code>docker run --link=[CONTAINER_NAME] [:ALIAS] [IMAGE] [COMMAND]</code></p>
<p><code>EG: docker run -it --name cct3 --link=cct1:webtest  dormancypress/cct1</code></p>
<ul>
<li><p>拒绝容器间互联</p>
<pre><code>Docker守护进程的启动选项
--icc = fasle
vim /etc/default/docker
DOCKER_OPTS=&apos; --icc = false&apos;
重启docker 服务
</code></pre></li>
<li><p>允许特定容器的间的链接</p>
<pre><code>守护进程的启动选项
--icc =false -iptables=true
    vim /etc/default/docker
    DOCKER_OPTS=&apos; --icc = false -iptables=true&apos;
    重启 docekr 服务

--link  创建容器时 加了 link 选项才可以被链接。
</code></pre></li>
</ul>
<h3 id="docker容器与外部网络的链接"><a href="#docker容器与外部网络的链接" class="headerlink" title="docker容器与外部网络的链接"></a>docker容器与外部网络的链接</h3><ul>
<li><p>ip_forward</p>
<p>  –ip_forward =true 它决定系统是否转发流量<br>  查看： sudo sysctl.ipv4.conf.all.forwaring</p>
<pre><code>net.ipv4.conf.all.forwarding = 1
</code></pre></li>
<li>iptables </li>
<li>允许端口映射访问</li>
<li>限制ip访问容器</li>
</ul>
<h3 id="docker容器的数据管理"><a href="#docker容器的数据管理" class="headerlink" title="docker容器的数据管理"></a>docker容器的数据管理</h3><ul>
<li>docker容器的数据卷</li>
<li>docker容器的卷容器</li>
<li>docker数据卷的备份与还原</li>
</ul>
<h3 id="容器的数据卷"><a href="#容器的数据卷" class="headerlink" title="容器的数据卷"></a>容器的数据卷</h3><ul>
<li>什么是数据卷<ul>
<li>数据卷是经过特殊设计的目录，可以绕过联合文件系统（UFS），为一个或多个容器提供访问。</li>
<li>数据卷设计的目的，在于数据的永久化，它完全独立与容器的生存周期，因此，Docker不会在容器删除时删除其挂载的数据卷，也不会存在类似的垃圾收集机制对容器引用的数据卷进行处理。</li>
</ul>
</li>
<li>数据卷的架构<ul>
<li>docker的数据卷是独立于docker的存在，存在于docker的宿主机中，与docker容器的生存周期是分离的</li>
<li>docker数据卷是存在于宿主机的文件系统中</li>
<li>docker 数据卷可以是 目录也可以是文件</li>
<li>docker容器可以利用数据卷的技术与宿主机进行数据共享</li>
<li>同一个数据文件可以支持多个容器的访问共享，实现了容器间的数据共享和交换</li>
</ul>
</li>
</ul>
<h3 id="数据卷（Data-Volume）的特点"><a href="#数据卷（Data-Volume）的特点" class="headerlink" title="数据卷（Data Volume）的特点"></a>数据卷（Data Volume）的特点</h3><ul>
<li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。</li>
<li>数据卷可以在容器之间共享和重用</li>
<li>可以对数据卷里的内容直接进行修改</li>
<li>数据卷的变化不会影响镜像的更新</li>
<li>数据卷会一直存在，即使挂载数据卷的容器已经被删除</li>
</ul>
<h3 id="数据卷的使用"><a href="#数据卷的使用" class="headerlink" title="数据卷的使用"></a>数据卷的使用</h3><ul>
<li>为容器添加数据卷 <code>sudo docker run -v ~/container_data:/data -it ubuntu /bin/bash</code></li>
<li>为数据卷添加访问权限 <code>sudo docker run -v ~/datavalume:/data:ro -it ubuntu /bin/bash</code>  在目录后面加权限</li>
<li>使用dockerfile 构建包含数据卷的镜像  Dockerfile指令： VOLUME[“/data”]</li>
</ul>
<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><ul>
<li>什么是数据卷容器：<ul>
<li>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器就叫做数据容器卷</li>
</ul>
</li>
<li>挂载数据卷容器的方法 <code>docker 润--volumes-from [CONTAINER NAME]</code></li>
<li>方便了在不同的容器间共享数据，不需要容器确切的连接到宿主机的准确目录。</li>
<li>若数据卷还在被容器使用，他就会一直存在。</li>
</ul>
<h3 id="docker数据卷的备份和还原"><a href="#docker数据卷的备份和还原" class="headerlink" title="docker数据卷的备份和还原"></a>docker数据卷的备份和还原</h3><ul>
<li>数据备份方法<br><code>docker run --vilumes-from [container name] -v $(pwd):/backup ubuntu  tar cvf /backup/backup.tar [container data volume]</code></li>
<li>数据还原方法<br><code>docker run --volumes-from [container name] -v $(pwd):/backup ubuntu tar xvf /backup/backup.tar [container data volume]</code></li>
</ul>
<h3 id="容器跨主机访问方法"><a href="#容器跨主机访问方法" class="headerlink" title="容器跨主机访问方法"></a>容器跨主机访问方法</h3><ul>
<li>使用网桥实现跨主机容器链接<ul>
<li>实现容器网段和主机网段一直，可以实现跨主机链接</li>
<li>配置较简单，不需要依赖第三方软件可实现</li>
<li>需要小心的规划容器哦，主机划分IP地址</li>
<li>需要有网段控制权，在生产环境中不易实现</li>
<li>不容易管理</li>
<li>兼容性不佳</li>
</ul>
</li>
<li>使用Open vSwitch 实现跨主机容器链接<ul>
<li>高质量，多层虚拟交换机，使用开源Apache2.0 许可协议，由Nicira Networks 开发</li>
<li>实现大规模网络自动化可以通过编程扩展，同时仍然支持标准的管理接口和协议。</li>
<li>GRE隧道： 通用路由协议封装<ul>
<li>隧道技术（Tunneling） 点对点 在封装 是一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据侦或包。隧道协议将其他协议的数据侦或包重新封装然后通过隧道发送。新的针头提供路由信息，以便通过互联网传递封装的负载数据。</li>
</ul>
</li>
</ul>
</li>
<li>使用 weave 实现跨主机容器链接<ul>
<li>weave 简介： 编织，建立一个虚拟的网络，用于将运行在不同主机的docker容器链接起来</li>
</ul>
</li>
</ul>
<h3 id="删除-docker-image"><a href="#删除-docker-image" class="headerlink" title="删除 docker image"></a>删除 docker image</h3><ul>
<li>docker中删除images的命令是docker rmi，但有时候执行此命令并不能删除images</li>
<li>ocker的帮助会发现有两个与删除有关的命令rm和rmi</li>
</ul>
<p>images和container。其中images很好理解，跟平常使用的虚拟机的镜像一个意思，相当于一个模版，而container则是images运行时的的状态。docker对于运行过的image都保留一个状态（container），可以使用命令docker ps来查看正在运行的container，对于已经退出的container，则可以使用docker ps -a来查看。 如果你退出了一个container而忘记保存其中的数据，你可以使用docker ps -a来找到对应的运行过的container使用docker commit命令将其保存为image然后运行。</p>
<p>由于image被某个container引用（拿来运行），如果不将这个引用的container销毁（删除），那image肯定是不能被删除。</p>
<p>要删除运行过的images必须首先删除它的container。 <code>dokcer ps -a</code></p>
<p>看出 image id 的image被 CONTAINER ID 的container使用着，所以必须首先删除该container</p>
<p>docker rm CONTAINER ID</p>
<p>若错误，可能是在执行，则需要stop ； docker stop CONTAINER ID</p>
<p>docker images</p>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 ,图片资源转自pexels © <a href="" target="_blank">Ocean</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/04/01/转-三大主流软件负载均衡对比/" class="pre-post btn btn-default" title='转-三大主流软件负载均衡对比'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">转-三大主流软件负载均衡对比</span>
        </a>
    
    
        <a href="/2019/02/14/入门图数据库/" class="next-post btn btn-default" title='入门图数据库'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">入门图数据库</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	<link rel="stylesheet" href="https://jjeejj.github.io/css/gitment.css">
<script src="https://jjeejj.github.io/js/gitment.js"></script>

<script>
    var gitment = new Gitment({
        id: 'Thu Feb 21 2019 20:11:52 GMT+0800',
        owner:"LiuHaiYang",
        repo:"liuhaiyang.github.io",
        oauth: {
          client_id:"aacf4f5555aee5bf0770",
          client_secret:"07f91d5b66c30419c14d14349ccadaa91300bc9c"
        },
        perPage:"10",
    });
    gitment.render('comments');
</script>

    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-学习操作记录"><span class="toc-text">docker 学习操作记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#helloworld"><span class="toc-text">helloworld</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#镜像加速"><span class="toc-text">镜像加速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基础命令："><span class="toc-text">基础命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#容器中部署web-网站"><span class="toc-text">容器中部署web 网站</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker镜像"><span class="toc-text">docker镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#镜像的操作："><span class="toc-text">镜像的操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取和推送镜像"><span class="toc-text">获取和推送镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#镜像配置："><span class="toc-text">镜像配置：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#推送镜像："><span class="toc-text">推送镜像：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何让构建docker的镜像："><span class="toc-text">如何让构建docker的镜像：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实践："><span class="toc-text">实践：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提交为镜像："><span class="toc-text">提交为镜像：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-build-通过Dockerfile-文件构建"><span class="toc-text">docker build 通过Dockerfile 文件构建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker的cs模式："><span class="toc-text">Docker的cs模式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-守护进程的配置和操作"><span class="toc-text">docker 守护进程的配置和操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-de-启动及选项：很多"><span class="toc-text">docker de 启动及选项：很多</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-的远程访问"><span class="toc-text">docker 的远程访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#客户端修改"><span class="toc-text">客户端修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#服务器端修改"><span class="toc-text">服务器端修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile"><span class="toc-text">Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第一个-Dockerfile"><span class="toc-text">第一个 Dockerfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指令"><span class="toc-text">指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker容器的网络基础"><span class="toc-text">Docker容器的网络基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的互联"><span class="toc-text">容器的互联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker容器与外部网络的链接"><span class="toc-text">docker容器与外部网络的链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker容器的数据管理"><span class="toc-text">docker容器的数据管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器的数据卷"><span class="toc-text">容器的数据卷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据卷（Data-Volume）的特点"><span class="toc-text">数据卷（Data Volume）的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据卷的使用"><span class="toc-text">数据卷的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据卷容器"><span class="toc-text">数据卷容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker数据卷的备份和还原"><span class="toc-text">docker数据卷的备份和还原</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器跨主机访问方法"><span class="toc-text">容器跨主机访问方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除-docker-image"><span class="toc-text">删除 docker image</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2019
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Ocean</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>